#!/usr/bin/python
# -*- coding: UTF-8 -*-

# КМЗИ. ЛР№2. DES

import sys

def getArgs():
	import argparse
	parser = argparse.ArgumentParser(prog = "des")
	parser.add_argument ('infile', type = argparse.FileType(mode='rb'), help = "input file")
	parser.add_argument ('key', help = "crypt key (8 symbols)")
	parser.add_argument ('outfile', type = argparse.FileType(mode='wb'), help = "output file")
	parser.add_argument ('crypt_decrypt', choices=['c', 'd'], help = "crypt or decrypt")
 	return parser.parse_args()

# получение 16 48-битных ключей шифрования для DES
def getKeys(key64):
	# правило выбора 56 бит из 64
	r = [
		57, 49, 41, 33, 25, 17, 9, 1,
		58, 50, 42, 34, 26, 18, 10, 2,
		59, 51, 43, 35, 27, 19, 11, 3,
		60, 52, 44, 36, 63, 55, 47, 39,
		31, 23, 15, 7, 62, 54, 46, 38,
		30, 22, 14, 6, 61, 53, 45, 37,
		29, 21, 13, 5, 28, 20, 12, 4]

	# берём необходимые 56 бит из 64
	key56 = [key64[r[i] - 1] for i in range(56)]

	# сколько раз надо сдвигать 56 битный ключ
	# для получения очередного 48 битного
	s = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]

	# правило выбора 48 бит из 56
	r2 = [
		14, 17, 11, 24, 1, 5, 3, 28,
		15, 6, 21, 10, 23, 19, 12, 4,
		26, 8, 16, 7, 27, 20, 13, 2,
		41, 52, 31, 37, 47, 55, 30, 40,
		51, 45, 33, 48, 44, 49, 39, 56,
		34, 53, 46, 42, 50, 36, 29, 32]

	keys = [0] * 16
	for j in range(16):
		# сдвигаем половинки ключа
		while (s[j] > 0):
			temp1 = key56[0];
			temp2 = key56[28];

			for i in range(55):
				if (i == 27):
					continue
				else:
					key56[i] = key56[i + 1]
			key56[27] = temp1
			key56[55] = temp2
			s[j] -= 1

		# собираем новый 48 битный ключ
		keys[j] = [key56[r2[i] - 1] for i in range(48)]
	return keys;


# подстановка с помощью S-блоков
# на входе - 48 бит, на выходе - 32	
def substitution(right48):
	SB = [
		[
			[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
			[0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
			[4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
			[15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]
		],

		[
			[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
			[3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
			[0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
			[13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]
		],

		[
			[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
			[13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
			[13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
			[1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]
		],

		[
			[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
			[13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
			[10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
			[3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]
		],

		[
			[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
			[14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
			[4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
			[11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]
		],

		[
			[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
			[10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 12, 14, 0, 11, 3, 8],
			[9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
			[4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]
		],

		[
			[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
			[13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
			[1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
			[6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]
		],

		[
			[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
			[1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
			[7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
			[2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]
		]
	]

	# разбиваем входные 48 бит на массивы по 6 бит
	r8x6 = []
	for i in range(8):
		bit6 = [0] * 6
		for j in range(6):
			bit6[j] = right48[i * 6 + j]
		r8x6.append(bit6)

	# преобразуем 8 частей по 6 бит в одну 32-битную
	# по S-блокам
	newRight32 = [0] * 32
	for i in range(8):
		# биты 1 и 6 - номер строки таблицы
		row = r8x6[i][0] * 2 + r8x6[i][5];

		# биты со 2 по 5 - номер столбца
		column = r8x6[i][1] * 8 + r8x6[i][2] * 4 + r8x6[i][3] * 2 + r8x6[i][4] * 1

		# получаем значение из таблиц
		sValue = SB[i][row][column]

		# потом полученное значение переводим в двоичный вид
		sBits = [0] * 4
		for j in range(4, 0, -1):
			sBits[j - 1] = sValue % 2
			sValue /= 2

		# записываем полученное значение к результату
		for j in range(4):
			newRight32[i * 4 + j] = sBits[j]

	return newRight32;

# один из 16 шагов алгоритма DES
def desStep(right, left, key48):
	# переставляем биты правой части так, чтобы из 32 бит стало 48
	E = [
		32, 1, 2, 3, 4, 5, 4, 5,
		6, 7, 8, 9, 8, 9, 10, 11,
		12, 13, 12, 13, 14, 15, 16, 17,
		16, 17, 18, 19, 20, 21, 20, 21,
		22, 23, 24, 25, 24, 25, 26, 27,
		28, 29, 28, 29, 30, 31, 32, 1]
	right48 = [right[E[i] - 1] for i in range(48)]

	# складываем по модулю 2 правую часть с ключом
	right48 = [right48[i] ^ key48[i] for i in range(48)]

	# прогоняем 48 бит через s-блоки
	newRight32 = substitution(right48)

	# простая перестановка
	per = [
		16, 7, 20, 21, 29, 12, 28, 17,
		1, 15, 23, 26, 5, 18, 31, 10,
		2, 8, 24, 14, 32, 27, 3, 9,
		19, 13, 30, 6, 22, 11, 4, 25]
	t = [newRight32[per[i] - 1] for i in range(32)]
	newRight32 = t

	# сложение по модулю 2 новой правой и старой левой частей
	newRight32 = [newRight32[i] ^ left[i] for i in range(32)]

	# после этого новый левый блок - старый правый
	left = right;
	right = newRight32;

	return right, left

# шифрование/дешифрование data ключом key
# шифрование и дешифрование отличаются только порядком передачи ключей	
def des(data, key, crypt):
 	# первым делом найдём битовое представление данных и ключа
	data64 = [0] * 64
	key64 = [0] * 64
	for i in range(8):
		d = ord(data[i])
		k = ord(key[i])
		for j in range(8):
			data64[i * 8 + j] = d % 2
			key64[i * 8 + j] = k % 2
			d /= 2
			k /= 2

	# получим 16 ключей шифрования на основе одного 64-битного
	keys = getKeys(key64)

	# разобъём данные на левую и правую половины
	left32 = data64[:32]
	right32 = data64[32:]

	# основные 16 шагов алгоритма
	# при шифровании и дешифровании различается только порядок передачи ключей
	for i in range(16):
		if crypt:
			right32, left32 = desStep(right32, left32, keys[i])
		else:
			right32, left32 = desStep(right32, left32, keys[15 - i]);


	# объединяем левую и правые части (учитывая, что на последнем шаге они не должны были менться местами
	data64 = right32 + left32

	# теперь битовое представление зашифрованных данных переведём обратно к строковому
	res = ""
	for i in range(8):
		d = 0
		for j in range(8):
			d += data64[i * 8 + j] * (2 ** j)
		res += chr(d)
	return res

def main():
	args = getArgs()

	if (len(args.key) != 8):
		print "Key must be 8 symbols!"
		sys.exit(1)

	if (args.crypt_decrypt == 'c'):
		# шифрование. Происходит кусочками по 8 байт.
		# если длина файла не кратна 8, то последний кусочек дополняется 0
		# и количество нулей записывается в конец выходного файла
		while True:
			part8 = args.infile.read(8)
			if not part8: # если файл кончился - выходим
				break

			nZeroes = 0 # количество нулей, которыми пришлось дополнить
			if len (part8) != 8:
				nZeroes = 8 - len(part8)
				for i in range(nZeroes): # само дополнение нулями
					part8 += chr(0)

			args.outfile.write(des(part8, args.key, True)) # записываем результат шифрования в файл
			if nZeroes:
				args.outfile.write(str(nZeroes)) # если пришлось дополнить нулями - запишем, сколько их было
				break # и выйдем
	else:
		# дешифрование. Происходит кусочками по 8 байт.
		# если вдруг размер файла не кратен 8, значит, в конец были добавлены нули
		# от них необходимо будет избавиться
		result = ""
		while True:
			part8 = args.infile.read(8)
			if not part8:
				args.outfile.write(result) # файл кончился. Запишем результат
				break

			if len(part8) != 8: # в таком случае мы считали 1 число - количество лишних нулей
				args.outfile.write(result[:-int(part8)]) # запишем результат в файл кроме последних нескольких символов
				break
			else: # иначе - просто дешифруем очередной кусок из 8 байт
				result += des(part8, args.key, False)

if __name__ == "__main__":
	main()